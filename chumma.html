<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style>
      

#landing{
  position: relative;
  height: 100vh;
  overflow: hidden;
  background: linear-gradient(to bottom, #020f1f, #002132, #00394a);
}

/* Canvas background */
#particle-canvas{
  position: absolute;
  inset: 0;
  z-index: 0;
}

/* Content above particles */
.landing-content{
  position: relative;
  z-index: 1;
  color: var(--light-text);
  text-align: center;
  padding-top: 40vh;
}

#fiber-canvas {
  position: absolute;
  inset: 0;
  z-index: 0;
}

#stress-canvas {
  position: absolute;
  inset: 0;
  z-index: 0;
}

#flow-canvas {
  position: absolute;
  inset: 0;
  z-index: 0;
}
#master-canvas {
  position: absolute;
  inset: 0;
  z-index: 0;
}


#bg-canvas {
  position: absolute;
  inset: 0;
  z-index: 0;
}

#particle-canvas {
  position: absolute;
  inset: 0;
  z-index: 0;
}

#dna-canvas {
  position: absolute;
  inset: 0;
  z-index: 0;
}


    </style>
</head>
<body>
    <section id="landing">
  <!-- <canvas id="particle-canvas"></canvas> -->
  <!-- <canvas id="fiber-canvas"></canvas> -->
   <!-- <canvas id="stress-canvas"></canvas> -->

   <!-- <canvas id="flow-canvas"></canvas> -->

   <!-- <canvas id="master-canvas"></canvas> -->
    <!-- <canvas id="bg-canvas"></canvas> -->

    <!-- <canvas id="particle-canvas"></canvas> -->

    <canvas id="dna-canvas"></canvas>




      

  <!-- Your content here -->
  <div class="landing-content">
    <!-- <h1>Your Hero Content</h1> -->
  </div>
</section>
<!-- atom animation  -->
<!-- <script>
    const canvas = document.getElementById("particle-canvas");
const ctx = canvas.getContext("2d");

let particles = [];
const PARTICLE_COUNT = 80;

function resizeCanvas() {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
}
resizeCanvas();
window.addEventListener("resize", resizeCanvas);

class Particle {
  constructor() {
    this.x = Math.random() * canvas.width;
    this.y = Math.random() * canvas.height;
    this.radius = Math.random() * 2 + 1;
    this.speedX = (Math.random() - 0.5) * 0.6;
    this.speedY = (Math.random() - 0.5) * 0.6;
  }

  draw() {
    ctx.beginPath();
    ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
    ctx.fillStyle = "rgba(88, 227, 225, 0.8)";
    ctx.fill();
  }

  update() {
    this.x += this.speedX;
    this.y += this.speedY;

    if (this.x < 0 || this.x > canvas.width) this.speedX *= -1;
    if (this.y < 0 || this.y > canvas.height) this.speedY *= -1;
  }
}

function initParticles() {
  particles = [];
  for (let i = 0; i < PARTICLE_COUNT; i++) {
    particles.push(new Particle());
  }
}
initParticles();

function connectParticles() {
  for (let i = 0; i < particles.length; i++) {
    for (let j = i; j < particles.length; j++) {
      const dx = particles[i].x - particles[j].x;
      const dy = particles[i].y - particles[j].y;
      const distance = Math.sqrt(dx * dx + dy * dy);

      if (distance < 120) {
        ctx.strokeStyle = `rgba(88,227,225,${1 - distance / 120})`;
        ctx.lineWidth = 0.5;
        ctx.beginPath();
        ctx.moveTo(particles[i].x, particles[i].y);
        ctx.lineTo(particles[j].x, particles[j].y);
        ctx.stroke();
      }
    }
  }
}

function animate() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  particles.forEach(p => {
    p.update();
    p.draw();
  });
  connectParticles();
  requestAnimationFrame(animate);
}

animate();

</script> -->
<!-- particle animation  -->
<!-- <script>
  const canvas = document.getElementById("particle-canvas");
  const ctx = canvas.getContext("2d");

  let particles = [];
  const PARTICLE_COUNT = 60;

  function resizeCanvas() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
  }
  resizeCanvas();
  window.addEventListener("resize", resizeCanvas);

  class Particle {
    constructor() {
      this.x = Math.random() * canvas.width;
      this.y = Math.random() * canvas.height;
      this.radius = Math.random() * 2 + 1.2;

      // Smooth slow movement
      this.vx = (Math.random() - 0.5) * 0.25;
      this.vy = (Math.random() - 0.5) * 0.25;
    }

    draw() {
      ctx.beginPath();
      ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
      ctx.fillStyle = "rgba(88, 227, 225, 0.85)";
      ctx.shadowBlur = 10;
      ctx.shadowColor = "#58e3e1";
      ctx.fill();
      ctx.shadowBlur = 0;
    }

    update() {
      this.x += this.vx;
      this.y += this.vy;

      // Soft bounce
      if (this.x <= 0 || this.x >= canvas.width) this.vx *= -1;
      if (this.y <= 0 || this.y >= canvas.height) this.vy *= -1;
    }
  }

  function initParticles() {
    particles = [];
    for (let i = 0; i < PARTICLE_COUNT; i++) {
      particles.push(new Particle());
    }
  }
  initParticles();

  function animate() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    particles.forEach(p => {
      p.update();
      p.draw();
    });

    requestAnimationFrame(animate);
  }

  animate();
</script> -->

<!-- fiber animation  -->
<!-- <script>
  const canvas = document.getElementById("fiber-canvas");
  const ctx = canvas.getContext("2d");

  function resize() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
  }
  resize();
  window.addEventListener("resize", resize);

  let time = 0;
  const LINES = 35;

  function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.lineWidth = 0.8;

    for (let i = 0; i < LINES; i++) {
      ctx.beginPath();
      ctx.strokeStyle = `rgba(88, 227, 225, ${0.15 + i * 0.003})`;

      for (let x = 0; x < canvas.width; x += 15) {
        const y =
          canvas.height / 2 +
          Math.sin(x * 0.01 + time + i * 0.4) * (30 + i * 3);

        ctx.lineTo(x, y + i * 8);
      }
      ctx.stroke();
    }

    time += 0.01;
    requestAnimationFrame(draw);
  }

  draw();
</script> -->

<!-- STRESS ANIMATION  -->
 <!-- <script>
  const canvas = document.getElementById("stress-canvas");
  const ctx = canvas.getContext("2d");


  function resize() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
  }
  resize();
  window.addEventListener("resize", resize);

  const fibers = [];
  const FIBER_COUNT = 140;
  let time = 0;

  class Fiber {
    constructor() {
      this.angle = Math.random() * Math.PI * 2;
      this.offset = Math.random() * 1000;
      this.speed = 0.001 + Math.random() * 0.002;
      this.thickness = Math.random() * 1.1 + 0.3;
      this.amplitude = 20 + Math.random() * 60;
    }

    draw() {
      ctx.beginPath();
      ctx.lineWidth = this.thickness;
      ctx.strokeStyle = "rgba(88,227,225,0.12)";

      for (let i = 0; i < 200; i++) {
        const t = i / 200;
        const x =
          canvas.width * t +
          Math.sin(t * 8 + time + this.offset) * this.amplitude *
            Math.cos(this.angle);

        const y =
          canvas.height * t +
          Math.cos(t * 8 + time + this.offset) * this.amplitude *
            Math.sin(this.angle);

        ctx.lineTo(x, y);
      }
      ctx.stroke();
    }
  }

  for (let i = 0; i < FIBER_COUNT; i++) {
    fibers.push(new Fiber());
  }

  function animate() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    fibers.forEach(f => f.draw());

    time += 0.005;
    requestAnimationFrame(animate);
  }

  animate();
    ctx.globalCompositeOperation = "lighter";

</script> -->

<!-- flow canvas  -->
 <!-- <script>
  const canvas = document.getElementById("flow-canvas");
  const ctx = canvas.getContext("2d");

  function resize() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
  }
  resize();
  window.addEventListener("resize", resize);

  const particles = [];
  const COUNT = 1800;
  const SCALE = 0.002;

  function noise(x, y) {
    return Math.sin(x * 12.9898 + y * 78.233) * 43758.5453 % 1;
  }

  class Particle {
    constructor() {
      this.reset();
    }

    reset() {
      this.x = Math.random() * canvas.width;
      this.y = Math.random() * canvas.height;
      this.life = Math.random() * 600 + 200;
    }

    update() {
      const angle =
        noise(this.x * SCALE, this.y * SCALE) * Math.PI * 2;

      this.vx = Math.cos(angle);
      this.vy = Math.sin(angle);

      this.x += this.vx * 0.6;
      this.y += this.vy * 0.6;

      this.life--;

      if (
        this.life <= 0 ||
        this.x < 0 || this.x > canvas.width ||
        this.y < 0 || this.y > canvas.height
      ) {
        this.reset();
      }
    }

    draw() {
      ctx.fillRect(this.x, this.y, 1, 1);
    }
  }

  for (let i = 0; i < COUNT; i++) {
    particles.push(new Particle());
  }

  function animate() {
    ctx.fillStyle = "rgba(0, 20, 30, 0.08)";
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    ctx.fillStyle = "rgba(88, 227, 225, 0.85)";

    particles.forEach(p => {
      p.update();
      p.draw();
    });

    requestAnimationFrame(animate);
  }

  animate();
</script> -->

<!-- master canvas  -->
 <!-- <script>
(() => {
  const canvas = document.getElementById("master-canvas");
  const ctx = canvas.getContext("2d");

  function resize() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
  }
  resize();
  window.addEventListener("resize", resize);

  /* ========= PARAMETERS ========= */
  const PARTICLE_COUNT = 3200;
  const STEP = 0.55;
  const NOISE_SCALE = 0.0015;
  const ROTATION_BIAS = Math.PI / 6; // anisotropy
  const FADE_ALPHA = 0.045;

  /* ========= SIMPLE GRADIENT NOISE ========= */
  function hash(x, y) {
    return Math.sin(x * 127.1 + y * 311.7) * 43758.5453123 % 1;
  }

  function smoothNoise(x, y) {
    const x0 = Math.floor(x);
    const y0 = Math.floor(y);
    const xf = x - x0;
    const yf = y - y0;

    const a = hash(x0, y0);
    const b = hash(x0 + 1, y0);
    const c = hash(x0, y0 + 1);
    const d = hash(x0 + 1, y0 + 1);

    const u = xf * xf * (3 - 2 * xf);
    const v = yf * yf * (3 - 2 * yf);

    return (
      a * (1 - u) * (1 - v) +
      b * u * (1 - v) +
      c * (1 - u) * v +
      d * u * v
    );
  }

  /* ========= PARTICLE ========= */
  class Particle {
    constructor(layer) {
      this.layer = layer;
      this.reset();
    }

    reset() {
      this.x = Math.random() * canvas.width;
      this.y = Math.random() * canvas.height;
      this.life = Math.random() * 2000 + 1000;
    }

    step() {
      const nx = this.x * NOISE_SCALE;
      const ny = this.y * NOISE_SCALE;

      const angle =
        smoothNoise(nx + this.layer * 10, ny) * Math.PI * 2 +
        ROTATION_BIAS * this.layer;

      this.x += Math.cos(angle) * STEP * (1 + this.layer * 0.25);
      this.y += Math.sin(angle) * STEP * (1 + this.layer * 0.25);

      this.life--;

      if (
        this.life <= 0 ||
        this.x < 0 || this.x > canvas.width ||
        this.y < 0 || this.y > canvas.height
      ) {
        this.reset();
      }
    }

    draw() {
      ctx.fillRect(this.x, this.y, 1, 1);
    }
  }

  /* ========= INIT ========= */
  const particles = [];
  for (let i = 0; i < PARTICLE_COUNT; i++) {
    particles.push(new Particle(Math.random() * 2));
  }

  ctx.globalCompositeOperation = "lighter";

  /* ========= ANIMATE ========= */
  function animate() {
    ctx.fillStyle = `rgba(0, 18, 28, ${FADE_ALPHA})`;
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    ctx.fillStyle = "rgba(88, 227, 225, 0.75)";

    for (const p of particles) {
      p.step();
      p.draw();
    }

    requestAnimationFrame(animate);
  }

  animate();
})();
</script> -->

<!-- bg-canvas  -->
 <!-- <script>
(() => {
  const canvas = document.getElementById("bg-canvas");
  const ctx = canvas.getContext("2d");

  function resize() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
  }
  resize();
  window.addEventListener("resize", resize);

  let t = 0;

  function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // very subtle drifting light
    for (let i = 0; i < 6; i++) {
      const x =
        canvas.width / 2 +
        Math.sin(t * 0.0004 + i) * canvas.width * 0.35;

      const y =
        canvas.height / 2 +
        Math.cos(t * 0.0003 + i) * canvas.height * 0.35;

      const r = canvas.width * 0.6;

      const grad = ctx.createRadialGradient(x, y, 0, x, y, r);
      grad.addColorStop(0, "rgba(88,227,225,0.035)");
      grad.addColorStop(1, "rgba(0,0,0,0)");

      ctx.fillStyle = grad;
      ctx.fillRect(0, 0, canvas.width, canvas.height);
    }

    t++;
    requestAnimationFrame(draw);
  }

  draw();
})();
</script> -->

<!-- bg canvas2  -->
<!-- <script>
(() => {
  const canvas = document.getElementById("bg-canvas");
  const ctx = canvas.getContext("2d");

  function resize() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
  }
  resize();
  window.addEventListener("resize", resize);

  let time = 0;
  const LINE_GAP = 28;

  function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.lineWidth = 1;

    for (let y = -50; y < canvas.height + 50; y += LINE_GAP) {
      ctx.beginPath();

      for (let x = 0; x <= canvas.width; x += 20) {
        const offset =
          Math.sin(x * 0.01 + time) * 18 +
          Math.sin(y * 0.015 + time * 0.8) * 12;

        ctx.lineTo(x, y + offset);
      }

      ctx.strokeStyle = "rgba(88, 227, 225, 0.45)";
      ctx.stroke();
    }

    time += 0.015; // <-- visible speed
    requestAnimationFrame(draw);
  }

  draw();
})();
</script> -->

<!-- <script>
(() => {
  const canvas = document.getElementById("bg-canvas");
  const ctx = canvas.getContext("2d");

  function resize() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
  }
  resize();
  window.addEventListener("resize", resize);

  let offset = 0;
  const GAP = 26;          // distance between fibers
  const SPEED = 0.6;       // visible but calm
  const ANGLE = Math.PI / 4; // 45° weave

  function drawWeave(angle, alpha) {
    ctx.save();
    ctx.rotate(angle);

    ctx.strokeStyle = `rgba(88,227,225,${alpha})`;
    ctx.lineWidth = 1.2;

    const size = Math.max(canvas.width, canvas.height) * 2;

    for (let i = -size; i < size; i += GAP) {
      ctx.beginPath();
      ctx.moveTo(i + offset, -size);
      ctx.lineTo(i + offset, size);
      ctx.stroke();
    }

    ctx.restore();
  }

  function animate() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    ctx.translate(canvas.width / 2, canvas.height / 2);

    // Layer 1
    drawWeave(ANGLE, 0.35);

    // Layer 2 (opposite direction)
    drawWeave(-ANGLE, 0.25);

    ctx.setTransform(1, 0, 0, 1, 0, 0);

    offset += SPEED;
    if (offset > GAP) offset = 0;

    requestAnimationFrame(animate);
  }

  animate();
})();
</script> -->

<!-- <script>
(() => {
  const canvas = document.getElementById("bg-canvas");
  const ctx = canvas.getContext("2d");

  function resize() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
  }
  resize();
  window.addEventListener("resize", resize);

  let t = 0;
  const BAND_WIDTH = 120;   // thickness of flow bands
  const SPEED = 0.02;       // visible motion
  const ANGLE = Math.PI / 6; // directional bias (anisotropy)

  function animate() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    ctx.save();
    ctx.translate(canvas.width / 2, canvas.height / 2);
    ctx.rotate(ANGLE);

    for (let i = -canvas.width * 2; i < canvas.width * 2; i += BAND_WIDTH) {
      const shift = Math.sin(t + i * 0.01) * 40;

      const grad = ctx.createLinearGradient(
        i + shift, -canvas.height,
        i + shift + BAND_WIDTH, canvas.height
      );

      grad.addColorStop(0, "rgba(88,227,225,0.0)");
      grad.addColorStop(0.5, "rgba(88,227,225,0.35)");
      grad.addColorStop(1, "rgba(88,227,225,0.0)");

      ctx.fillStyle = grad;
      ctx.fillRect(
        i + shift,
        -canvas.height * 2,
        BAND_WIDTH,
        canvas.height * 4
      );
    }

    ctx.restore();

    t += SPEED;
    requestAnimationFrame(animate);
  }

  animate();
})();
</script> -->

<!-- particle  -->
 <!-- <script>
(() => {
  const canvas = document.getElementById("particle-canvas");
  const ctx = canvas.getContext("2d");

  function resize() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
  }
  resize();
  window.addEventListener("resize", resize);

  const particles = [];
  const COUNT = 220;        // visible but not crowded
  const SPEED = 0.6;        // smooth & visible
  const DRIFT = 0.003;      // flow field strength

  function fieldAngle(x, y, t) {
    return Math.sin(x * DRIFT + t) + Math.cos(y * DRIFT + t * 0.7);
  }

  class Particle {
    constructor() {
      this.reset();
    }

    reset() {
      this.x = Math.random() * canvas.width;
      this.y = Math.random() * canvas.height;
      this.r = Math.random() * 2.2 + 1.2; // visible size
    }

    update(t) {
      const angle = fieldAngle(this.x, this.y, t);
      this.x += Math.cos(angle) * SPEED;
      this.y += Math.sin(angle) * SPEED;

      if (
        this.x < -20 || this.x > canvas.width + 20 ||
        this.y < -20 || this.y > canvas.height + 20
      ) {
        this.reset();
      }
    }

    draw() {
      ctx.beginPath();
      ctx.arc(this.x, this.y, this.r, 0, Math.PI * 2);
      ctx.fillStyle = "rgba(88,227,225,0.85)";
      ctx.shadowBlur = 8;
      ctx.shadowColor = "#58e3e1";
      ctx.fill();
    }
  }

  for (let i = 0; i < COUNT; i++) {
    particles.push(new Particle());
  }

  let t = 0;

  function animate() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    particles.forEach(p => {
      p.update(t);
      p.draw();
    });

    t += 0.01;
    requestAnimationFrame(animate);
  }

  animate();
})();
</script> -->

<!-- dna  -->
 <!-- <script>
(() => {
  const canvas = document.getElementById("dna-canvas");
  const ctx = canvas.getContext("2d");

  function resize() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
  }
  resize();
  window.addEventListener("resize", resize);

  const PARTICLES = 240;
  const RADIUS = 140;
  const SPEED = 0.02;

  let time = 0;
  const strands = [];

  class HelixParticle {
    constructor(offset) {
      this.offset = offset;
      this.y = Math.random() * canvas.height;
    }

    update() {
      this.y -= 0.6;
      if (this.y < -100) this.y = canvas.height + 100;
    }

    draw(t, direction) {
      const angle = t + this.offset + this.y * 0.02;
      const x =
        canvas.width / 2 +
        Math.cos(angle) * RADIUS * direction;

      const scale = (Math.sin(angle) + 1.5) / 2.5; // depth illusion
      const r = 2 + scale * 2.5;

      ctx.beginPath();
      ctx.arc(x, this.y, r, 0, Math.PI * 2);
      ctx.fillStyle = `rgba(88,227,225,${0.4 + scale * 0.6})`;
      ctx.shadowBlur = 10;
      ctx.shadowColor = "#58e3e1";
      ctx.fill();
    }
  }

  for (let i = 0; i < PARTICLES; i++) {
    strands.push(new HelixParticle(i * 0.25));
  }

  function animate() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    strands.forEach(p => {
      p.update();
      p.draw(time, 1);
      p.draw(time + Math.PI, -1); // second strand
    });

    time += SPEED;
    requestAnimationFrame(animate);
  }

  animate();
})();
</script> -->

<script>
(() => {
  const canvas = document.getElementById("dna-canvas");
  const ctx = canvas.getContext("2d");

  function resize() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
  }
  resize();
  window.addEventListener("resize", resize);

  const PARTICLES = 260;
  const BASE_RADIUS = 150;
  const SPEED = 0.02;
  const TILT = (120 * Math.PI) / 180; // 120° rotation

  let time = 0;
  const particles = [];

  class HelixParticle {
    constructor(offset) {
      this.offset = offset;
      this.t = Math.random() * canvas.height;
    }

    update() {
      this.t -= 0.7;
      if (this.t < -200) this.t = canvas.height + 200;
    }

    draw(globalTime, phaseShift) {
      const wave = globalTime + this.offset + this.t * 0.02;

      // Converge / Diverge breathing
      const breathe = 0.65 + Math.sin(globalTime * 1.2) * 0.35;
      const radius = BASE_RADIUS * breathe;

      const x0 = Math.cos(wave + phaseShift) * radius;
      const y0 = this.t;

      // Rotate whole DNA (tilt)
      const x =
        x0 * Math.cos(TILT) - y0 * Math.sin(TILT) +
        canvas.width / 2;

      const y =
        x0 * Math.sin(TILT) + y0 * Math.cos(TILT) +
        canvas.height / 2 - 200;

      const depth = (Math.sin(wave) + 1.5) / 2.5;
      const r = 2.2 + depth * 2.8;

      ctx.beginPath();
      ctx.arc(x, y, r, 0, Math.PI * 2);
      ctx.fillStyle = `rgba(88,227,225,${0.35 + depth * 0.6})`;
      ctx.shadowBlur = 12;
      ctx.shadowColor = "#58e3e1";
      ctx.fill();
    }
  }

  for (let i = 0; i < PARTICLES; i++) {
    particles.push(new HelixParticle(i * 0.28));
  }

  function animate() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    particles.forEach(p => {
      p.update();
      p.draw(time, 0);           // strand 1
      p.draw(time, Math.PI);     // strand 2
    });

    time += SPEED;
    requestAnimationFrame(animate);
  }

  animate();
})();
</script>

</body>
</html>